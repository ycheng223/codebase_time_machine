import unittest
import ast
import sys
import io

# The implementation to be tested, provided from subtask 1.2.1.2
def parse_python_code_to_ast(source_code: str):
    """
    Parses a string of Python source code into an Abstract Syntax Tree (AST).

    This function leverages Python's built-in 'ast' module to perform the parsing.
    It is a simple wrapper that includes error handling for invalid syntax.

    Args:
        source_code: A string containing the Python code to be parsed.

    Returns:
        An 'ast.Module' object representing the root of the AST if the parsing
        is successful. Returns None if the source code contains a syntax error.
    """
    try:
        # The ast.parse() function is the core component that builds the tree.
        # It takes the source string and returns the root node of the AST.
        tree = ast.parse(source_code)
        return tree
    except SyntaxError as e:
        # If the source code is not syntactically correct Python,
        # ast.parse() raises a SyntaxError. We catch it here.
        # Note: The original implementation printed, which we will test for.
        print(f"Error: Invalid syntax in the provided code. Details: {e}")
        return None

# A simulated downstream component that consumes the AST generated by the parser.
# This integration test verifies that the parser's output is usable by such a component.
class AstStructureAnalyzer(ast.NodeVisitor):
    """
    A simple AST visitor that acts as a consumer of the parser's output.
    It walks the AST to find and record the names of all defined functions and classes.
    """
    def __init__(self):
        self.found_functions = []
        self.found_classes = []

    def visit_FunctionDef(self, node: ast.FunctionDef):
        """Called for every function definition node."""
        self.found_functions.append(node.name)
        self.generic_visit(node)  # To visit nested functions

    def visit_ClassDef(self, node: ast.ClassDef):
        """Called for every class definition node."""
        self.found_classes.append(node.name)
        self.generic_visit(node)  # To visit methods and nested classes

class TestCodeParsingAndAnalysisIntegration(unittest.TestCase):
    """
    Integration test for the 'Code Parsing and AST Generation' task.

    This test verifies the end-to-end process:
    1. A string of Python code is passed to `parse_python_code_to_ast`.
    2. The function generates an AST object.
    3. A separate analysis component (`AstStructureAnalyzer`) successfully consumes
       this AST object to extract meaningful information.
    This confirms that the parser not only works in isolation but also correctly
    integrates with other components that rely on its output.
    """
    def setUp(self):
        """Redirect stdout to capture print statements from error handling."""
        self.held_stdout, sys.stdout = sys.stdout, io.StringIO()

    def tearDown(self):
        """Restore stdout after each test."""
        sys.stdout = self.held_stdout

    def test_integration_successful_parsing_and_analysis(self):
        """
        Tests the successful integration path: valid code is parsed, and the
        resulting AST is correctly analyzed.
        """
        source_code = """
class MyClass:
    def method_one(self):
        pass

def top_level_function():
    def nested_function():
        pass
    return nested_function
"""
        # Step 1: Use the parser to generate the AST
        ast_tree = parse_python_code_to_ast(source_code)

        # Assert that parsing was successful
        self.assertIsNotNone(ast_tree, "Parser should successfully process valid code.")
        self.assertIsInstance(ast_tree, ast.Module, "Parser should return an ast.Module object.")

        # Step 2: Integrate the AST with the analysis component
        analyzer = AstStructureAnalyzer()
        analyzer.visit(ast_tree)

        # Step 3: Verify the analyzer extracted the correct information
        self.assertEqual(sorted(analyzer.found_classes), ['MyClass'])
        self.assertEqual(sorted(analyzer.found_functions), ['method_one', 'nested_function', 'top_level_function'])

    def test_integration_parsing_failure_handling(self):
        """
        Tests that a parsing failure is handled correctly in the integrated workflow.
        The parser should return None, and the downstream logic should handle this gracefully.
        """
        invalid_source_code = "for i in range(10)"  # Missing colon

        # Step 1: Use the parser, which is expected to fail
        ast_tree = parse_python_code_to_ast(invalid_source_code)

        # Assert that parsing failed as expected
        self.assertIsNone(ast_tree, "Parser should return None for syntactically invalid code.")

        # Verify that the expected error message was printed
        output = sys.stdout.getvalue()
        self.assertIn("Error: Invalid syntax", output)

        # Step 2 & 3: Simulate downstream logic and verify it doesn't run or fail
        analyzer = AstStructureAnalyzer()
        if ast_tree is not None:
            # This block should not be executed
            analyzer.visit(ast_tree)

        self.assertEqual(analyzer.found_classes, [], "Analyzer should not find classes if parsing fails.")
        self.assertEqual(analyzer.found_functions, [], "Analyzer should not find functions if parsing fails.")

    def test_integration_with_code_having_no_declarations(self):
        """
        Tests that the integration works correctly for valid code that simply
        lacks the structures the analyzer is looking for.
        """
        source_code = """
import os
x = 10 * 5
print("Hello, World!")
"""
        # Step 1: Parse the code
        ast_tree = parse_python_code_to_ast(source_code)
        self.assertIsNotNone(ast_tree, "Parser should handle valid code without declarations.")

        # Step 2: Analyze the resulting AST
        analyzer = AstStructureAnalyzer()
        analyzer.visit(ast_tree)

        # Step 3: Verify that the analyzer correctly found nothing
        self.assertEqual(analyzer.found_classes, [], "Analyzer should find no classes.")
        self.assertEqual(analyzer.found_functions, [], "Analyzer should find no functions.")

    def test_integration_with_empty_source_code(self):
        """
        Tests the integration workflow with an empty string as input, which is valid.
        """
        source_code = ""

        # Step 1: Parse the empty code
        ast_tree = parse_python_code_to_ast(source_code)
        self.assertIsNotNone(ast_tree, "Parser should handle an empty string.")
        self.assertEqual(len(ast_tree.body), 0, "AST for empty code should have an empty body.")

        # Step 2: Analyze the empty AST
        analyzer = AstStructureAnalyzer()
        analyzer.visit(ast_tree)

        # Step 3: Verify the analyzer found nothing
        self.assertEqual(analyzer.found_classes, [])
        self.assertEqual(analyzer.found_functions, [])

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)